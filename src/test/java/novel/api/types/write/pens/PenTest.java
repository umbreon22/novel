package novel.api.types.write.pens;

import novel.internal.testutil.DataPenQueue;
import novel.internal.testutil.MinimumNumberValueComparator;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Supplier;
import java.util.stream.BaseStream;

public abstract class PenTest {

    DataPenQueue newPen() {
        return new DataPenQueue();
    }

    @Test
    abstract void testIterable();

    @Test
    abstract void testStreams();

    <T> void testIterable(Iterable<T> iterable, BiFunction<DataPenQueue, Iterable<T>, DataPenQueue> writeIterable) {
        var queue = writeIterable.apply(newPen(), iterable).queue();
        Assertions.assertEquals(iterable, queue);
    }

    <T, S extends BaseStream<T, S>> void testObjectStreams(Supplier<S> streamSupplier, BiFunction<DataPenQueue, S, DataPenQueue> writeStream) {
        testObjectStreams(streamSupplier, writeStream, Assertions::assertEquals);
    }

    /**
     * {@link Number} itself is not {@link Comparable}, so we pass in {@code assertion}.
     */
    <B extends Number, T extends B, S extends BaseStream<T, S>> void testNumberStreams(
            Supplier<S> streamSupplier,
            BiFunction<DataPenQueue, S, DataPenQueue> writeStream,
            BiConsumer<B, B> assertion
    ) {
        testObjectStreams(streamSupplier, writeStream, assertion);
    }

    @SuppressWarnings("unchecked")//let it fail
    <B, T extends B, S extends BaseStream<T, S>> void testObjectStreams(
        Supplier<S> streamSupplier,
        BiFunction<DataPenQueue, S, DataPenQueue> writeStream,
        BiConsumer<B, B> assertion
    ) {
        Collection<Object> collectedWrites = writeStream.apply(newPen(), streamSupplier.get()).queue();
        Collection<Object> collectedStream = collectBaseStream(streamSupplier.get());
        Assertions.assertEquals(collectedStream.size(), collectedWrites.size());
        Iterator<Object> writeIt = writeStream.apply(newPen(), streamSupplier.get()).queue().iterator();
        Iterator<Object> streamIt = collectBaseStream(streamSupplier.get()).iterator();
        do {
            B a = (B) streamIt.next();
            B b = (B) writeIt.next();
            assertion.accept(a, b);
        } while(writeIt.hasNext() || streamIt.hasNext());
    }

    /**
     * Because {@link Number} itself is not {@link Comparable}
     */
    <B extends Number, T extends B, S extends BaseStream<T, S>> void testNumberStreams(Supplier<S> streamSupplier, BiFunction<DataPenQueue, S, DataPenQueue> writeStream) {
        Comparator<Number> cmp = new MinimumNumberValueComparator();
        BiConsumer<Number, Number> assertion = (a, b) -> {
            int compare = cmp.compare(a, b);
            Assertions.assertEquals(0, compare);
        };
        testNumberStreams(streamSupplier, writeStream, assertion);
    }


    protected static <T, S extends BaseStream<T, S>> Collection<Object> collectBaseStream(S stream) {
        Collection<Object> collection = new LinkedList<>();
        stream.iterator().forEachRemaining(collection::add);
        return collection;
    }

    /**
     * Writes a 2d array as flattened values to
     * and returns a {@link DataPenQueue}
     */
    <T> DataPenQueue writeClonedMatrix(T objects, BiConsumer<DataPen, T[]> arrayMethod) {
        @SuppressWarnings("unchecked")
        T[] twoDimensions = (T[]) Array.newInstance(
            objects.getClass().getComponentType().arrayType(),
            Array.getLength(objects)
        );
        Arrays.fill(twoDimensions, objects);
        var pen = newPen();
        arrayMethod.accept(pen, twoDimensions);
        return pen;
    }

    void assertClonedMatrixEqualsSource(Object[] source, Queue<Object> flatMatrix) {
        while(!flatMatrix.isEmpty()) {
            for (var datum : source) {
                Assertions.assertEquals(datum, flatMatrix.poll());
            }
        }
    }

    void assertClonedMatrixEqualsSource(Iterable<?> source, Queue<Object> flatMatrix) {
        while(!flatMatrix.isEmpty()) {
            for (var datum : source) {
                Assertions.assertEquals(datum, flatMatrix.poll());
            }
        }
    }

    /**
     * Messy, but it'll do.
     * Boxes an array, if it can!
     */
    Object[] boxedArray(Object probablyPrimitiveArray) {
        Assertions.assertTrue(probablyPrimitiveArray.getClass()::isArray);
        Class<?> box = getBoxedClass(probablyPrimitiveArray.getClass().getComponentType());
        Object[] object = (Object[]) Array.newInstance(
            box, Array.getLength(probablyPrimitiveArray)
        );
        Arrays.setAll(object, index -> box.cast(Array.get(probablyPrimitiveArray, index)));
        return object;
    }

    private static final Map<Class<?>, Class<?>> boxedTypes = Map.of(
        int.class, Integer.class,
        short.class, Short.class,
        byte.class, Byte.class,
        long.class, Long.class,
        float.class, Float.class,
        boolean.class, Boolean.class,
        char.class, Character.class,
        double.class, Double.class
    );

    private Class<?> getBoxedClass(Class<?> componentType) {
        if(!componentType.isPrimitive()) {
            return componentType;
        } else {
            return boxedTypes.get(componentType);
        }
    }
}
