package novel.api.types.write.pens;

import novel.api.types.write.writers.CharDataWriter;
import novel.internal.testutil.DataPenQueue;
import novel.internal.testutil.NumberValueComparator;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;

public class CharPenTest extends PenTest {

    @Test
    void charsTest() {
        char[] data = {'a', 'b', 'c'};
        var singlePen = newPen();
        for(var d : data) singlePen.chars(d);

        var varArgsPen = newPen();
        varArgsPen.chars(data);
        Assertions.assertEquals(singlePen.queue(), varArgsPen.queue());

        var supplierPen = newPen();
        for(var d : data) supplierPen.chars(()->d);
        Assertions.assertEquals(singlePen.queue(), supplierPen.queue());

        var matrixPenQueue = writeClonedMatrix(data, DataPen::chars).queue();
        assertClonedMatrixEqualsSource(
            boxedArray(data),
            matrixPenQueue
        );
    }

    @Test
    @Override
    void testIterable() {
        testIterable(List.of('a', 'b'), DataPenQueue::chars);
    }

    @Test
    @Override
    void testStreams() {
        Comparator<Object> comparing = numberAndCharComparator(0);
        Comparator<Object> comparingPlusOne = numberAndCharComparator(1);
        BiConsumer<Object, Object> cmpEqual = (a, b) -> Assertions.assertEquals(0, comparing.compare(a, b));
        BiConsumer<Object, Object> cmpPlusOne = (a, b) -> Assertions.assertEquals(0, comparingPlusOne.compare(a, b));
        CharDataWriter writePlusOne = (pen, c) -> pen.chars((char)(c+1));

        Supplier<Stream<Character>> charStreamSupplier = () -> Stream.of('a', 'b', 'c');
        testObjectStreams(charStreamSupplier, DataPenQueue::chars, cmpEqual);
        testObjectStreams(charStreamSupplier, (p, c) -> p.chars(c, writePlusOne), cmpPlusOne);

        Supplier<IntStream> intStreamSupplier = () -> IntStream.of('a', 'b', 'c');
        testObjectStreams(intStreamSupplier, DataPenQueue::chars, cmpEqual);
        testObjectStreams(intStreamSupplier, (p, c) -> p.chars(c, writePlusOne), cmpPlusOne);

        Supplier<DoubleStream> doubleStreamSupplier = () -> DoubleStream.of('a', 'b', 'c');
        testObjectStreams(doubleStreamSupplier, DataPenQueue::chars, cmpEqual);
        testObjectStreams(doubleStreamSupplier, (p, c) -> p.chars(c, writePlusOne), cmpPlusOne);

        Supplier<LongStream> longStreamSupplier = () -> LongStream.of('a', 'b', 'c');
        testObjectStreams(longStreamSupplier, DataPenQueue::chars, cmpEqual);
        testObjectStreams(longStreamSupplier, (p, c) -> p.chars(c, writePlusOne), cmpPlusOne);
    }

    private Comparator<Object> numberAndCharComparator(int offset) {
        return new Comparator<>() {
            private char convert(Object o) {
                char ret;
                if(o instanceof Number) {
                    ret = (char) ((Number)o).longValue();
                } else if(o instanceof Character){
                    ret = (char) o;
                } else {
                    throw new IllegalArgumentException(o.getClass().getSimpleName() + " is not supported by this comparator.");
                }
                return ret;
            }
            @Override
            public int compare(Object a, Object b) {
                return Character.compare((char) (convert(a) + offset), convert(b));
            }
        };
    }

    @Test
    void testDataWriter() {
        char[] data = {'a', 'b', 'c'};
        CharDataWriter dataWriter = (pen, c) -> pen.chars((char)(c+1));
        List<Character> transformedData = Stream.of('a', 'b', 'c', 'd')//not worth it
                                                .map(c->(char)(c+1))
                                                .collect(Collectors.toList());
        Queue<?> result = newPen().chars(data, dataWriter).chars('d', dataWriter).queue();
        Assertions.assertEquals(transformedData, result);

        List<Character> dataList = new LinkedList<>();
        for(char c : data) dataList.add(c);
        result = newPen().chars(dataList, dataWriter).chars('d', dataWriter).queue();
        Assertions.assertEquals(transformedData, result);
    }

}
