package novel.api.types.write.pens;

import novel.api.types.write.writers.ByteDataWriter;
import novel.internal.testutil.DataPenQueue;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;

public class BytePenTest extends PenTest {

    @Test
    void bytesTest() {
        byte[] data = {0, 1, 2};
        var singlePen = newPen();
        for(var d : data) singlePen.bytes(d);

        var varArgsPen = newPen();
        varArgsPen.bytes(data);
        Assertions.assertEquals(singlePen.queue(), varArgsPen.queue());

        var supplierPen = newPen();
        for(var d : data) supplierPen.bytes(()->d);
        Assertions.assertEquals(singlePen.queue(), supplierPen.queue());

        var matrixPenQueue = writeClonedMatrix(
            data, BytePen::bytes
        ).queue();

        assertClonedMatrixEqualsSource(
            boxedArray(data),
            matrixPenQueue
        );
    }

    @Test
    @Override
    void testIterable() {
        testIterable(List.of((byte)0, (byte)1), DataPenQueue::bytes);
    }

    @Test
    @Override
    void testStreams() {
        BiConsumer<Number, Number> assertPlusOne = (expected, result) -> {
            int compare = Byte.compare((byte) (expected.byteValue() + 1), result.byteValue());
            Assertions.assertEquals(0, compare);
        };
        ByteDataWriter bytePlusOne = (p, b) -> p.bytes((byte)(b+1));
        Supplier<Stream<Byte>> byteStreamSupplier = () -> Stream.of(
            Byte.MIN_VALUE, (byte) 1, (byte) 2, (byte) 3, Byte.MAX_VALUE
        );
        testNumberStreams(byteStreamSupplier, DataPenQueue::bytes);
        testNumberStreams(byteStreamSupplier, (p, n) -> p.bytes(n, bytePlusOne), assertPlusOne);

        Supplier<IntStream> intStreamSupplier = () -> IntStream.of(
            Integer.MIN_VALUE, 1, 2, 3, Integer.MAX_VALUE
        );
        testNumberStreams(intStreamSupplier, DataPenQueue::bytes);
        testNumberStreams(intStreamSupplier, (p, n) -> p.bytes(n, bytePlusOne), assertPlusOne);

        Supplier<LongStream> longStreamSupplier = () -> LongStream.of(
            Long.MIN_VALUE, 1L, 2L, 3L, Long.MAX_VALUE
        );
        testNumberStreams(longStreamSupplier, DataPenQueue::bytes);
        testNumberStreams(longStreamSupplier, (p, n) -> p.bytes(n, bytePlusOne), assertPlusOne);

        Supplier<DoubleStream> doubleStreamSupplier = () -> DoubleStream.of(
            Double.MIN_VALUE, 1, 2, 3, Double.MAX_VALUE
        );
        testNumberStreams(doubleStreamSupplier, DataPenQueue::bytes);
        testNumberStreams(doubleStreamSupplier, (p, n) -> p.bytes(n, bytePlusOne), assertPlusOne);
    }

    @Test
    void testDataWriter() {
        byte[] data = {1, 2, 3};
        ByteDataWriter dataWriter = (pen, i) -> pen.bytes((byte)(i*2));
        List<Byte> transformedData = Stream.of(1, 2, 3, 1)//not worth it
                                           .map(i->i*2)
                                           .map(Integer::byteValue)
                                           .collect(Collectors.toList());
        var result = newPen().bytes(data, dataWriter).bytes((byte)1, dataWriter).queue();
        Assertions.assertEquals(transformedData, result);
    }
}
